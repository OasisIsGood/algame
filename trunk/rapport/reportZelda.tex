\documentclass[a4paper,11pt]{article}

\usepackage[ansinew]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage[paper=a4paper, top=1cm, bottom=1cm, left=2cm, right=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{xcolor}

\title{\large{\bfseries{ARCHITECTURE LOGICIELLE}}}
\author{Beno\^it V\'edrenne, Ga\"{e}l Walter}

\begin{document}

\maketitle

\begin{center}
\emph{Charg\'e de TD :} Damien Cassou\end{center}

\vspace{0.5cm}

\begin{center}
\includegraphics[width=2.5cm,height=2.5cm]{images/bdx1.eps}\\
\large{Universit\'e Bordeaux 1,\\
351 cours de la Lib\'eration,\\
33405 Talence Cedex,\\
France}
\end{center} 

\vspace{0cm}

\begin{center}
 \includegraphics[width=9cm,height=9cm]{images/zeldaNintendo.eps}
\end{center}

\begin{center}
 \large{The Cremi Legend Of Zelda}
\end{center}

\begin{abstract}
La l\'egende raconte que la grande for\^et d'Hyrule est occup\'ee par Ganon, le
puissant Prince des T\'en\`ebres. Ganon a captur\'e la fille du Roi qui tenta de s\'eparer la
Triforce, puissant sortil\`ege qui prot\`ege le royaume d'Hyrule. Ses guardes
mal\'efiques avancent \`a grand pas dans la for\^et en d\'etruisant tout sur leurs
passages\ldots \\
Il existe cependant un chevalier courageux, en ces temps de manants. 
On le reconnait facilement \`a sa chevelure blonde sous sa longue cape
verte. Apprenant la nouvelle de l'invasion, le regard noir,
il parti dans les haut bois de la for\^et d'Hyrule pour les affronter tous et
lib\'erer la fille du Roi nomm\'ee ``Zelda''.\\

The ``CREMI Legend of Zelda'', c'est l'histoire de ce jeune garçon, nomm\'e Link qui doit sauver la princesse Zelda au p\'eril de sa vie. \\
Une somme d'emb\^{u}ches l'attend. L'art de manier son \'ep\'ee pourra peut
\^etre l'aider dans sa qu\^ete impossible: seul contre une arm\'ee enti\`ere.
\end{abstract}

\newpage

\section{Introduction}
Le framework de jeu plateforme dont nous disposions, nous a permis
d'impl\'ementer une version du Jeu Zelda. Ce jeu, cr\'e\'e par Miyamoto (auteur
\'egalement de Donkey Kong et Mario), poss\`ede une version Nintendo de 1986. \\

Notre application s'inspire de cette version, o\`u l'on peut guider dans une
for\^et le personnage Link. \\
Nous l'avons bien s\^{u}r d\'enomm\'e Cremi Legend Of Zelda car il a \'et\'e
principalement d\'evelopp\'e au Cremi !

\subsection{Comment jouer \`a CLOZ ?}
Le but du jeu est de guider Link dans la for\^et pour l'amener \`a la
princesse Zelda avec les
touches fl\'ech\'ees. \\ 
On devra tout d'abord \'eliminer tout ses ennemis mal\'efiques en utilisant le coup
d'attaque par la touche ``Espace''. Ceux ci sont tr\`es \'enerv\'es car
ils ont \'et\'e pr\'evenus de l'arriv\'e de Link, c'est pour cela qu'ils n'ont pas un
comportement tr\`es logiques. Parfois, il se peut qu'un ennemi plus robuste
surveille plus raisonnablement Zelda, il est donc plus difficile \`a
tuer. Il ne faut pas h\'esiter \`a les frapper de mani\`ere r\'ep\'et\'ee.\\

La difficult\'e du jeu r\'eside dans le nombre d'ennemis \`a tuer, plus ou moins
forts selon leurs grades, mais aussi dans les diff\'erents objets
qui peuvent agr\'ementer le jeu. Le joueur est libre de tous les
essayer. Mais comme dans la r\'ealit\'e, les bombes blessent.\\

La vie de Link d\'emarre \`a ``100'' mais elle peut descendre tr\`es
vite ! Faites attention Link, n'est pas immortel. En mourrant, vous
recommencerez le jeu au d\'ebut du niveau.

\subsection{Quelques r\`egles du jeu}
Seul le clavier est utile au jeu, mais le menu permet d'autres actions.\\
Au croisement avec des ennemis, Link perd de la vie car il se fait
frapper par ceux-ci. Les boss notament sont plus coriaces (de vrais brutes), et
tapent plus fort. Si notre h\'eros meurt, le niveau de
jeu red\'emarre au d\'ebut. \\
Depuis le menu, on peut red\'emarrer la partie au d\'ebut, mais aussi sauvegarder la
partie ou (en th\'eorie) en restaurer une.\\
Lorsque tout les ennemis sont tu\'es, il faut aller vers la princesse et le
niveau est gagn\'e, on passe alors automatiquement au niveau suivant, s'il existe.
On peut trouver une arme sur le sol, Link peut attaquer avec. Il est possible
que certaines actions enl\`event cette arme, et le combat de boss devient plus
ardu.

\subsection{Astuces}
Comme dans beaucoup de jeu vid\'eo d'aventure, nous avons laiss\'e des codes
secrets que l'on peut chercher si l'on veut. Qu'il est agr\'eable en \'etant joueur
de trouver ce genre de code ! Mais n'oubliez pas que l'abus de codes nuit
au plaisir de jouer.

\newpage

\section{Conception}
La première phase du projet fût d'étudier le framework donné, ainsi que le code
du jeu Pacman. Le framework nous permet de créer un jeu basé sur un univers
donné, des entités évoluant dans ce monde selon des règles de collisions
données. Nous avons commencé à utiliser les classes du jeu Pacman pour débuter
Zelda. Ce fût non seulement un moyen de comprendre plus vite comment utiliser
certaines fonctionnalités du framework, mais aussi une difficulté de commencer
à vouloir adapter un jeu déjà fait à un autre, plutôt que de partir sur une
base saine.\\
Ce choix nous amena à ajouter petit à petit les différentes fonctionnalités en
plus que nous voulions.

\subsection{Pacquetages}
Au fur et à mesure de l'implémentation, nous avons mis en place une
arborescence de paquetages de classes, séparant bien chaque partie du code, ce
qui nous a permis de nous retrouver plus facilement tout au long du projet. On
retrouve ``\textbf{base}'', ``\textbf{game}'' comme dans le framework, mais
aussi ``\textbf{rule}', ``\textbf{entity}'' comme dans la version de Pacman.\\

Le paquetage ``\textbf{zelda}'' comprend plusieurs paquetages.\\
Le paquetage ``\textbf{base}'' permet de g\'erer l'intéraction utilisateur,
sons, gestion de mouvements de personnages.\\ 
Le paquetage ``\textbf{rule}'' contient les règles de gestion de collisions ou blocages entre entit\'es du jeu.\\ 
Le paquetage
``\textbf{level}'' permet de g\'erer la mise en place des niveaux du jeu, de la
lecture de fichier pour les niveaux, \`a la cr\'eation de niveaux.\\ 
Le paquetage
``\textbf{game}'' contient les classes n\'ecessaires \`a la cr\'eation du jeu
(gestion de l'univers, sauvegarde de niveaux\ldots).\\ 
Le paquetage
``\textbf{observer}'' permet de g\'erer tout les observateurs du jeu.\\ 
Le paquetage ``\textbf{entity}'' poss\`ede toutes les classes de toutes les entit\'es 
pr\'esentes dans le jeu : personnages et d\'ecors. Dans les personnages, un paquetage 
est r\'eserv\'e aux \'etats de Link.\\

\subsection{Architecture g\'en\'erale}


\begin{center}
 %\includegraphics[width=9cm,height=9cm]{images/archiGenerale.eps}
\end{center}

\subsection{Architecture d\'etaill\'ee}

\subsubsection*{Une Fabrique Abstraite pour cr\'eer le niveau depuis un fichier
texte}
Nous avons choisi d'utilis\'e une fabrique abstraite pour permettre la
cr\'eation et l'ajout d'entit\'es dans le niveau. Il \'etait assez intéressant
de cr\'eer cette fabrique abstraite car ainsi nous ne faisions juste qu'une
demande de cr\'eation d'un certain objet qu'elle s'occupait d'instancier. Une
personne voulant cr\'eer un personnage ou une autre entit\'e a juste besoin de
faire appel \`a la m\'{e}thode create ad\'equate. Cependant, le probl\`eme le
plus important et qui est un probl\`eme propre \`a ce mod\`ele est que l'ajout de 
nouvelles entit\'es est assez fastidieux : à
chaque nouvel objet il faut une m\'ethode pour le créer. Dans les constructeurs
de niveaux actuels il faut ajouter dans la table de hashage la méthode associée.

\begin{center}
 %\includegraphics[width=9cm,height=9cm]{images/abstFab.eps}
\end{center}

\subsubsection*{Le pattern Monteur pour sauvegarder la partie}
Le fait de sauvegarder la partie est une action classique de tout
jeu. Il nous est apparu comme \'evident d'avoir une repr\'esentation sur
fichier du contenu de cette sauvegarde. Nous avons donc mis en place un
monteur, celui-ci en effet est particuli\`erement adapt\'e \`a ce genre de
situation. Nous avons donc cr\'eer un monteur concret qui permet d'\'ecrire
un fichier texte contenant les informations ainsi sauvegardée.\\
Un autre avantage de ce patron de conception est que nous pouvons ainsi
rapidement modifier la repr\'esentation de cette sauvegarde. Il est tout \`a
fait possible d'imaginer une sauvegarde au format HTML ou XML, ou on ne
sait dans quel autre format. Le format de la sauvegarde est donc facilement
modifiable pour n'importe quelle personne reprennant notre code et qui
n'aimerait pas notre repr\'esentation. \\

\begin{center}
 \includegraphics[width=9cm,height=9cm]{images/Buildersdiagram.eps}
\end{center}

Nous avons aussi utilis\'e ce mod\`ele pour la lecture de la sauvegarde
ainsi que la lecture du fichier de cr\'eation de niveau et ce pour les
m\^{e}me raisons que celles \'enonc\'ees juste avant.

\subsubsection*{Gestion des \'etats de Link avec le pattern Etat}
L'\'etat de Link modifie son comportement. Ces changements
apparaissent de façon dynamique, selon les \'evènements du jeu, ou du joueur.
Cette intention nous a amen\'e \`a utiliser le pattern Etat pour g\'erer Link. Celui
ci peut d\'el\'eguer son comportement changeant \`a une hi\'erarchie de classes
LinkState poss\'edant des requ\^etes sp\'ecifiques comme l'utilisation de l'arme, le
mode attaque, la mort du personnage\ldots
Sur la fin du d\'eveloppement, cette conception nous a permis de rajouter
rapidement de nouveaux \'etats, et d'ajuster le comportement voulu facilement. \\

\begin{center}
 \includegraphics[scale=0.8]{images/Statediagram.eps}
\end{center}
 
\subsubsection*{un Singleton pour gérer le nombre d'ennemis dans le niveau}
Dans le jeu, une des priorité est d'éliminer tout les ennemis afin de pouvoir
finir le niveau. Afin de gérer le nombre d'ennemis, on crée un observateur
unique à qui on adresse en début de niveau le nombre d'ennemis à tuer.
L'intérêt est ici de créer une unique instance d'observateur et de fournir un
point d'accès global à celle ci depuis toutes les classes du jeu. L'utilisation
du modèle Singleton fût alors évident.

\begin{center}
 \includegraphics[scale=1]{images/Observerdiagram.eps}
\end{center}
 
\section{Evolutions}
Notre jeu Zelda n'est pas complètement fini, il ne comprend que quelques
niveaux, comprenant quelques ennemis, et quelques objets classiques. 
Quelques sprites ne sont pas parfaits, ni complets.\\
Cependant, le jeu fonctionne correctement, les fonctionnalités que nous
voulions au départ étant implémentées.\\

Nous aurions voulu, avec plus de temps, produire des niveaux plus riches en
entités, plus agréables à jouer. Le jeu semble trop court, et nous aurions voulu
développer un scénario plus attractif.

\subsection{Critiques}
Le mouvement des gardes a été honteusement copié de celui des ``ghosts'' du Jeu
Pacman donné, dans un premier temps, ce qui nous a permis de nous concentrer
sur d'autres éléments du jeu. Finalement nous nous sommes habitués à ces
mouvements primitifs qui ajoutent une difficulté au jeu. Nous pourrions créer
une autre méthode de déplacement, plus intelligente, qui suivrait un
déplacement précalculé. Une bonne aptitude des gardes serait de changer de
méthode déplacement et aller attaquer Link dès qu'il s'approche trop près de
Zelda ou trop près d'une zone donnée.\\

Les sons ne sont pas assez nombreux, ce qui laisse une part de silence trop
grande, mais le système de son est mis en place, ce qui nous relie aux besoins
du projet même.
 
\section{Implémentation}

\subsection*{Problèmes rencontrés}

Nous avons bien sûr rencontré plusieurs points difficiles.

\subsubsection*{Gestion des niveaux}

Nous avons mis en place plusieurs niveaux ainsi qu'un changement de ceux-ci, 
ce qui s'avéra \^etre une t\^ache ardu. En effet, nous pouvons passer au niveau 
suivant sans problème mais choisir au hasard un niveau et le lancer est
malheureusement impossible. Nous avons voulu mettre en place un système
utilisant ceci via le rechargement de sauvegarde. Avec notre implémentation,
quand nous rechargeons un niveau, le niveau se charge mais celui-ci ne démarre
pas. Nous avons tenté de diverse façon de faire en sorte que cela fonctionne
sans résultat. En fait, le plus compliqué vient de l'utilisation des threads
qui doivent être interrompus avant de passer au niveau suivant et le niveau
suivant doit être lancé. Mais pour des raisons inconnus, les threads ne se
lancent pas.

\subsubsection*{XML}

En théorie, il est possible de créer des niveaux au format XML grâce au
Monteur LevelReader, malheureusement nous avons eu des difficultés à mettre en
place ce lecteur de XML. Nous n'avons pas réussi surement à cause du fait que
nous n'avions jamais utilisé l'API correspondante auparavant, et les
différents tutoriaux présent sur internet n'ont pas suffit à nous permettre
de réussir.

\subsubsection*{Le framework de base}

Le fait d'être confronté à un framework dont nous ne pouvions rien toucher,
fut un challenge intéressant mais cependant parfois compliqué. Il nous est
arrivé à plusieurs reprise de vouloir récupérer une chose d'une classe du
framework, alors que cette chose ne nous était pas accessible ou encore
modifier une variable privée inaccessible de l'extèrieur. Nous avons
parfois été tenté par la recopie de code (ce que nous pouvons apercevoir
avec la classe GameZeldaAWTImpl) mais il fallait le plus souvent trouver des
astuces. Ces astuces étaient souvent des modèles de conceptions, par exemple
nous avons utilisé un décorateur pour permettre d'attendre les
fonctionnalités d'une interface qui ne nous permettait pas de récupérer une
variable pourtant essentielle sans laquelle le jeu aurait paru étrange aux yeux
des divers joueurs.

\subsubsection*{Gestion des sprites}

Une des principales difficultés fût de gérer correctement les sprites. 

\end{document}
